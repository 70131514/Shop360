rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isEmailVerified() {
      return isSignedIn() && request.auth.token.email_verified == true;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function isAdmin() {
      return isSignedIn()
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    match /users/{uid} {

      // Create your own user document at signup
      allow create: if isOwner(uid)
        && request.resource.data.keys().hasOnly(['uid','name','email','role','isEmailVerified','createdAt'])
        && request.resource.data.uid == uid
        && request.resource.data.email == request.auth.token.email
        && request.resource.data.role == 'user'
        // Email/password users will be false here, Google users will be true here.
        && request.resource.data.isEmailVerified == (request.auth.token.email_verified == true);

      // Read your own profile
      allow get: if isOwner(uid) && isEmailVerified();

      function profileKeysOk() {
        return request.resource.data.keys().hasOnly(['uid','name','email','role','isEmailVerified','createdAt']);
      }

      function profileBaseUnchanged() {
        return request.resource.data.uid == resource.data.uid
          && request.resource.data.role == resource.data.role
          && request.resource.data.createdAt == resource.data.createdAt;
      }

      // Normal profile updates (e.g., name) only after email verification
      function safeVerifiedProfileUpdate() {
        return isEmailVerified()
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.email == resource.data.email
          && request.resource.data.isEmailVerified == resource.data.isEmailVerified;
      }

      // Allow flipping Firestore flag false -> true after email verification (best-effort sync)
      function verifyFlagUpdate() {
        return isEmailVerified()
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.email == resource.data.email
          && resource.data.isEmailVerified == false
          && request.resource.data.isEmailVerified == true
          && request.resource.data.name == resource.data.name;
      }

      // Allow changing email in Firestore immediately after Firebase Auth `updateEmail()`.
      // At this point, `request.auth.token.email` is the NEW email but `email_verified` is false.
      function emailChangeUpdate() {
        return isOwner(uid)
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.name == resource.data.name
          && resource.data.isEmailVerified == true
          && request.resource.data.isEmailVerified == false
          && request.resource.data.email == request.auth.token.email
          && request.resource.data.email != resource.data.email;
      }

      allow update: if isOwner(uid) && (safeVerifiedProfileUpdate() || verifyFlagUpdate() || emailChangeUpdate());

      // Optional: allow delete your doc (usually false in prod)
      allow delete: if false;

      // Disallow listing all users by default
      allow list: if isAdmin() && isEmailVerified();

      // ✅ Cart subcollection (per-user)
      match /cart/{productId} {
        allow get, list: if isOwner(uid) && isEmailVerified();

        allow create, update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'id','name','price','image','quantity','brand','originalPrice','inStock','addedAt','updatedAt'
          ])
          && request.resource.data.id == productId;

        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Wishlist subcollection (per-user)
      match /wishlist/{productId} {
        allow get, list: if isOwner(uid) && isEmailVerified();

        // Create/update wishlist item (only allow safe fields)
        allow create, update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'id','name','brand','price','originalPrice','image','inStock','addedAt'
          ])
          && request.resource.data.id == productId;

        // Remove wishlist item
        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Addresses subcollection (per-user)
      match /addresses/{addressId} {
        allow get, list: if isOwner(uid) && isEmailVerified();

        allow create: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'name',
            'street',
            'city',
            'state',
            'zipCode',
            'country',
            'isDefault',
            'latitude',
            'longitude',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.name is string
          && request.resource.data.street is string
          && request.resource.data.city is string
          && request.resource.data.state is string
          && request.resource.data.zipCode is string
          && request.resource.data.country is string
          && request.resource.data.isDefault is bool;

        allow update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'name',
            'street',
            'city',
            'state',
            'zipCode',
            'country',
            'isDefault',
            'latitude',
            'longitude',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.name is string
          && request.resource.data.street is string
          && request.resource.data.city is string
          && request.resource.data.state is string
          && request.resource.data.zipCode is string
          && request.resource.data.country is string
          && request.resource.data.isDefault is bool;

        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Orders subcollection (per-user)
      match /orders/{orderId} {
        // Users can only read/list their own orders
        allow get, list: if (isOwner(uid) && isEmailVerified()) || (isAdmin() && isEmailVerified());

        // Users can create orders only for themselves (written by the app after checkout)
        allow create: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'userId',
            'status',
            'createdAt',
            'updatedAt',
            'items',
            'itemCount',
            'subtotal',
            'shipping',
            'total',
            'address'
          ])
          && request.resource.data.userId == uid
          && request.resource.data.items is list
          && request.resource.data.address is map;

        // Typically orders shouldn't be editable by the client after creation
        allow update, delete: if false;
      }
    }

    // ✅ Products collection (admin-managed)
    match /products/{productId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // Everything else locked down
    match /{document=**} {
      allow read, write: if false;
    }
  }
}


