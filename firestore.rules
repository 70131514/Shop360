rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isEmailVerified() {
      return isSignedIn() && request.auth.token.email_verified == true;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function isAdmin() {
      return isSignedIn()
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    match /users/{uid} {

      // Create your own user document at signup
      // Allow any role if it matches a pre-assigned role, otherwise default to 'user'
      allow create: if isOwner(uid)
        && request.resource.data.keys().hasOnly(['uid','name','email','role','avatarId','isEmailVerified','createdAt'])
        && request.resource.data.uid == uid
        && request.resource.data.email == request.auth.token.email
        && (request.resource.data.role == 'user' || request.resource.data.role is string)
        // Email/password users will be false here, Google users will be true here.
        && request.resource.data.isEmailVerified == (request.auth.token.email_verified == true);

      // Read your own profile
      allow get: if isOwner(uid) && isEmailVerified();

      // Admins can read any user profile
      allow get: if isAdmin() && isEmailVerified();

      function profileKeysOk() {
        return request.resource.data.keys().hasOnly(['uid','name','email','role','avatarId','isEmailVerified','createdAt']);
      }

      function profileBaseUnchanged() {
        return request.resource.data.uid == resource.data.uid
          && request.resource.data.role == resource.data.role
          && request.resource.data.createdAt == resource.data.createdAt;
      }

      // Normal profile updates (e.g., name) only after email verification
      function safeVerifiedProfileUpdate() {
        return isEmailVerified()
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.email == resource.data.email
          && request.resource.data.isEmailVerified == resource.data.isEmailVerified;
      }

      // Allow flipping Firestore flag false -> true after email verification (best-effort sync)
      function verifyFlagUpdate() {
        return isEmailVerified()
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.email == resource.data.email
          && resource.data.isEmailVerified == false
          && request.resource.data.isEmailVerified == true
          && request.resource.data.name == resource.data.name;
      }

      // Allow changing email in Firestore immediately after Firebase Auth `updateEmail()`.
      // At this point, `request.auth.token.email` is the NEW email but `email_verified` is false.
      function emailChangeUpdate() {
        return isOwner(uid)
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.name == resource.data.name
          && resource.data.isEmailVerified == true
          && request.resource.data.isEmailVerified == false
          && request.resource.data.email == request.auth.token.email
          && request.resource.data.email != resource.data.email;
      }

      allow update: if isOwner(uid) && (safeVerifiedProfileUpdate() || verifyFlagUpdate() || emailChangeUpdate());

      // Admins can update user roles
      allow update: if isAdmin() && isEmailVerified()
        && request.resource.data.keys().hasAll(['uid','name','email','role','isEmailVerified','createdAt'])
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.name == resource.data.name
        && request.resource.data.email == resource.data.email
        && request.resource.data.isEmailVerified == resource.data.isEmailVerified
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.avatarId == resource.data.avatarId
        && request.resource.data.role is string
        && request.resource.data.role != resource.data.role;

      // Optional: allow delete your doc (usually false in prod)
      allow delete: if false;

      // Disallow listing all users by default
      allow list: if isAdmin() && isEmailVerified();

      // ✅ Cart subcollection (per-user)
      match /cart/{productId} {
        allow get, list: if isOwner(uid) && isEmailVerified();

        allow create, update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'id','name','price','image','quantity','brand','originalPrice','inStock','stock','addedAt','updatedAt'
          ])
          && request.resource.data.id == productId;

        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Wishlist subcollection (per-user)
      match /wishlist/{productId} {
        allow get, list: if isOwner(uid) && isEmailVerified();

        // Create/update wishlist item (only allow safe fields)
        allow create, update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'id','name','brand','price','originalPrice','image','inStock','addedAt'
          ])
          && request.resource.data.id == productId;

        // Remove wishlist item
        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Addresses subcollection (per-user)
      match /addresses/{addressId} {
        allow get, list: if (isOwner(uid) && isEmailVerified()) || (isAdmin() && isEmailVerified());

        allow create: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'name',
            'street',
            'city',
            'state',
            'zipCode',
            'country',
            'isDefault',
            'latitude',
            'longitude',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.name is string
          && request.resource.data.street is string
          && request.resource.data.city is string
          && request.resource.data.state is string
          && request.resource.data.zipCode is string
          && request.resource.data.country is string
          && request.resource.data.isDefault is bool;

        allow update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'name',
            'street',
            'city',
            'state',
            'zipCode',
            'country',
            'isDefault',
            'latitude',
            'longitude',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.name is string
          && request.resource.data.street is string
          && request.resource.data.city is string
          && request.resource.data.state is string
          && request.resource.data.zipCode is string
          && request.resource.data.country is string
          && request.resource.data.isDefault is bool;

        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Payment Methods subcollection (per-user)
      match /paymentMethods/{cardId} {
        // Users can only read/list their own payment methods
        allow get, list: if isOwner(uid) && isEmailVerified();

        // Users can create payment methods only for themselves
        allow create: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'userId',
            'cardType',
            'last4',
            'expiryMonth',
            'expiryYear',
            'cardholderName',
            'isDefault',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.userId == uid
          && request.resource.data.cardType in ['visa', 'mastercard', 'amex', 'discover']
          && request.resource.data.last4 is string
          && request.resource.data.expiryMonth is string
          && request.resource.data.expiryYear is string
          && request.resource.data.isDefault is bool;

        // Users can update their own payment methods
        allow update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'userId',
            'cardType',
            'last4',
            'expiryMonth',
            'expiryYear',
            'cardholderName',
            'isDefault',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.userId == uid
          && request.resource.data.cardType in ['visa', 'mastercard', 'amex', 'discover']
          && request.resource.data.last4 is string
          && request.resource.data.expiryMonth is string
          && request.resource.data.expiryYear is string
          && request.resource.data.isDefault is bool;

        // Users can delete their own payment methods
        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Notifications subcollection (per-user)
      match /notifications/{notificationId} {
        // Users can only read/list their own notifications (must be verified)
        allow get, list: if isOwner(uid) && isEmailVerified();

        // System can create notifications for users (via admin or server-side)
        // Users cannot create their own notifications
        allow create: if isAdmin() && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'title',
            'message',
            'type',
            'read',
            'data',
            'createdAt'
          ])
          && request.resource.data.title is string
          && request.resource.data.message is string
          && request.resource.data.type in ['product_removed', 'order_update', 'promotion', 'general']
          && request.resource.data.read is bool
          && request.resource.data.read == false;

        // Users can update their own notifications (mark as read)
        allow update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read'])
          && request.resource.data.read is bool
          && request.resource.data.read == true
          && resource.data.read == false
          && request.resource.data.title == resource.data.title
          && request.resource.data.message == resource.data.message
          && request.resource.data.type == resource.data.type
          && request.resource.data.createdAt == resource.data.createdAt;

        // Admins can update notifications (for system updates)
        allow update: if isAdmin() && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'title',
            'message',
            'type',
            'read',
            'data',
            'createdAt'
          ]);

        // Users can delete their own notifications
        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Orders subcollection (per-user)
      match /orders/{orderId} {
        // Users can only read/list their own orders
        allow get, list: if (isOwner(uid) && isEmailVerified()) || (isAdmin() && isEmailVerified());

        // Users can create orders only for themselves (written by the app after checkout)
        allow create: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasAll([
            'userId',
            'status',
            'paymentMethod',
            'createdAt',
            'updatedAt',
            'items',
            'itemCount',
            'subtotal',
            'shipping',
            'total',
            'address'
          ])
          && request.resource.data.keys().hasOnly([
            'userId',
            'status',
            'paymentMethod',
            'paymentCardId',
            'createdAt',
            'updatedAt',
            'timeline',
            'items',
            'itemCount',
            'subtotal',
            'shipping',
            'total',
            'address'
          ])
          && request.resource.data.userId == uid
          && request.resource.data.items is list
          && request.resource.data.address is map
          && request.resource.data.paymentMethod in ['cash_on_delivery', 'card_payment']
          && (request.resource.data.paymentMethod == 'cash_on_delivery' || 
              (request.resource.data.paymentMethod == 'card_payment' && 
               request.resource.data.paymentCardId is string))
          && request.resource.data.timeline is list;

        // Users can request cancellation (update cancellation fields only)
        allow update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
            'cancellationRequested',
            'cancellationRequestedAt',
            'cancellationReason',
            'cancellationRejected',
            'cancellationRejectedAt',
            'cancellationRejectionReason',
            'updatedAt'
          ])
          && request.resource.data.cancellationRequested is bool
          && request.resource.data.userId == resource.data.userId;

        // Admins can update order status, timeline, handle cancellations, and mark as viewed
        allow update: if isAdmin() && isEmailVerified()
          && (
            // Status update
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt', 'timeline'])
             && request.resource.data.status in ['processing', 'shipped', 'delivered', 'cancelled']
             && request.resource.data.timeline is list)
            ||
            // Cancellation approval/rejection
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly([
              'cancellationRequested',
              'cancellationRejected',
              'cancellationRejectedAt',
              'cancellationRejectionReason',
              'status',
              'timeline',
              'updatedAt'
            ]))
            ||
            // Mark as viewed
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewedByAdmin', 'viewedAt', 'updatedAt'])
             && request.resource.data.viewedByAdmin is bool)
          );

        // Users cannot update or delete their orders
        allow delete: if false;
      }
    }

    // ✅ Products collection (admin-managed)
    match /products/{productId} {
      // Anyone can read products (for public product listings and details)
      allow read: if true;
      
      // Only verified admins can create or delete products
      allow create, delete: if isAdmin() && isEmailVerified();
      
      // Admins can update any field
      // Authenticated users can only update stock field (for order placement - stock decrements)
      allow update: if (isAdmin() && isEmailVerified()) ||
        (isSignedIn() && isEmailVerified() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['stock', 'updatedAt']) &&
         request.resource.data.stock is number &&
         resource.data.stock is number &&
         request.resource.data.stock < resource.data.stock); // Only allow stock decreases
    }

    // ✅ Categories collection (admin-managed)
    match /categories/{categoryId} {
      // Anyone can read categories (for public category listings and filters)
      allow read: if true;
      // Only verified admins can create, update, or delete categories
      allow create, update, delete: if isAdmin() && isEmailVerified();
    }

    // ✅ Role assignments collection (pre-assigned roles by email)
    match /roleAssignments/{email} {
      // Admins manage assignments
      allow create, delete, list: if isAdmin() && isEmailVerified();
      // Users can read ONLY their own assignment doc (docId == their auth email)
      // This enables signup to apply pre-assigned roles safely.
      allow get: if isSignedIn() && request.auth.token.email == email;
      allow update: if false; // Role assignments are immutable, delete and recreate to change
    }

    // ✅ Tickets collection (support inquiries)
    match /tickets/{ticketId} {
      // Only verified users can create tickets (guests cannot)
      allow create: if isSignedIn() && isEmailVerified()
        && request.resource.data.keys().hasOnly([
          'userId',
          'userEmail',
          'userName',
          'message',
          'status',
          'createdAt',
          'updatedAt',
          'viewedByAdmin',
          'timeline'
        ])
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.userEmail == request.auth.token.email
        && request.resource.data.status == 'open'
        && request.resource.data.message is string
        && request.resource.data.message.size() > 0
        && request.resource.data.viewedByAdmin == false;

      // Users can read their own tickets (must be verified)
      allow get, list: if isSignedIn() && isEmailVerified()
        && resource.data.userId == request.auth.uid;

      // Admins can read all tickets
      allow get, list: if isAdmin() && isEmailVerified();

      // Only admins can update tickets (to change status, mark as viewed, etc.)
      // Timeline is optional and can be added/updated
      function validTicketUpdate() {
        return request.resource.data.userId == resource.data.userId
          && request.resource.data.userEmail == resource.data.userEmail
          && request.resource.data.userName == resource.data.userName
          && request.resource.data.message == resource.data.message
          && request.resource.data.createdAt == resource.data.createdAt
          && request.resource.data.status is string;
      }
      allow update: if isAdmin() && isEmailVerified() && validTicketUpdate();

      // No one can delete tickets (for record keeping)
      allow delete: if false;
    }

    // ✅ Collection Group Queries
    // Allow admins to query orders collection group (for admin dashboard)
    match /{path=**}/orders/{orderId} {
      allow read: if isAdmin() && isEmailVerified();
    }

    // Everything else locked down
    match /{document=**} {
      allow read, write: if false;
    }
  }
}