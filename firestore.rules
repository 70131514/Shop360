rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isEmailVerified() {
      return isSignedIn() && request.auth.token.email_verified == true;
    }

    function isOwner(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function isAdmin() {
      return isSignedIn()
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    match /users/{uid} {

      // Create your own user document at signup
      // Allow any role if it matches a pre-assigned role, otherwise default to 'user'
      allow create: if isOwner(uid)
        && request.resource.data.keys().hasOnly(['uid','name','email','role','isEmailVerified','createdAt'])
        && request.resource.data.uid == uid
        && request.resource.data.email == request.auth.token.email
        && (request.resource.data.role == 'user' || request.resource.data.role is string)
        // Email/password users will be false here, Google users will be true here.
        && request.resource.data.isEmailVerified == (request.auth.token.email_verified == true);

      // Read your own profile
      allow get: if isOwner(uid) && isEmailVerified();

      // Admins can read any user profile
      allow get: if isAdmin() && isEmailVerified();

      function profileKeysOk() {
        return request.resource.data.keys().hasOnly(['uid','name','email','role','isEmailVerified','createdAt']);
      }

      function profileBaseUnchanged() {
        return request.resource.data.uid == resource.data.uid
          && request.resource.data.role == resource.data.role
          && request.resource.data.createdAt == resource.data.createdAt;
      }

      // Normal profile updates (e.g., name) only after email verification
      function safeVerifiedProfileUpdate() {
        return isEmailVerified()
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.email == resource.data.email
          && request.resource.data.isEmailVerified == resource.data.isEmailVerified;
      }

      // Allow flipping Firestore flag false -> true after email verification (best-effort sync)
      function verifyFlagUpdate() {
        return isEmailVerified()
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.email == resource.data.email
          && resource.data.isEmailVerified == false
          && request.resource.data.isEmailVerified == true
          && request.resource.data.name == resource.data.name;
      }

      // Allow changing email in Firestore immediately after Firebase Auth `updateEmail()`.
      // At this point, `request.auth.token.email` is the NEW email but `email_verified` is false.
      function emailChangeUpdate() {
        return isOwner(uid)
          && profileKeysOk()
          && profileBaseUnchanged()
          && request.resource.data.name == resource.data.name
          && resource.data.isEmailVerified == true
          && request.resource.data.isEmailVerified == false
          && request.resource.data.email == request.auth.token.email
          && request.resource.data.email != resource.data.email;
      }

      allow update: if isOwner(uid) && (safeVerifiedProfileUpdate() || verifyFlagUpdate() || emailChangeUpdate());

      // Admins can update user roles
      allow update: if isAdmin() && isEmailVerified()
        && request.resource.data.keys().hasAll(['uid','name','email','role','isEmailVerified','createdAt'])
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.name == resource.data.name
        && request.resource.data.email == resource.data.email
        && request.resource.data.isEmailVerified == resource.data.isEmailVerified
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.role is string
        && request.resource.data.role != resource.data.role;

      // Optional: allow delete your doc (usually false in prod)
      allow delete: if false;

      // Disallow listing all users by default
      allow list: if isAdmin() && isEmailVerified();

      // ✅ Cart subcollection (per-user)
      match /cart/{productId} {
        allow get, list: if isOwner(uid) && isEmailVerified();

        allow create, update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'id','name','price','image','quantity','brand','originalPrice','inStock','addedAt','updatedAt'
          ])
          && request.resource.data.id == productId;

        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Wishlist subcollection (per-user)
      match /wishlist/{productId} {
        allow get, list: if isOwner(uid) && isEmailVerified();

        // Create/update wishlist item (only allow safe fields)
        allow create, update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'id','name','brand','price','originalPrice','image','inStock','addedAt'
          ])
          && request.resource.data.id == productId;

        // Remove wishlist item
        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Addresses subcollection (per-user)
      match /addresses/{addressId} {
        allow get, list: if (isOwner(uid) && isEmailVerified()) || (isAdmin() && isEmailVerified());

        allow create: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'name',
            'street',
            'city',
            'state',
            'zipCode',
            'country',
            'isDefault',
            'latitude',
            'longitude',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.name is string
          && request.resource.data.street is string
          && request.resource.data.city is string
          && request.resource.data.state is string
          && request.resource.data.zipCode is string
          && request.resource.data.country is string
          && request.resource.data.isDefault is bool;

        allow update: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'name',
            'street',
            'city',
            'state',
            'zipCode',
            'country',
            'isDefault',
            'latitude',
            'longitude',
            'createdAt',
            'updatedAt'
          ])
          && request.resource.data.name is string
          && request.resource.data.street is string
          && request.resource.data.city is string
          && request.resource.data.state is string
          && request.resource.data.zipCode is string
          && request.resource.data.country is string
          && request.resource.data.isDefault is bool;

        allow delete: if isOwner(uid) && isEmailVerified();
      }

      // ✅ Orders subcollection (per-user)
      match /orders/{orderId} {
        // Users can only read/list their own orders
        allow get, list: if (isOwner(uid) && isEmailVerified()) || (isAdmin() && isEmailVerified());

        // Users can create orders only for themselves (written by the app after checkout)
        allow create: if isOwner(uid) && isEmailVerified()
          && request.resource.data.keys().hasOnly([
            'userId',
            'status',
            'createdAt',
            'updatedAt',
            'items',
            'itemCount',
            'subtotal',
            'shipping',
            'total',
            'address'
          ])
          && request.resource.data.userId == uid
          && request.resource.data.items is list
          && request.resource.data.address is map;

        // Typically orders shouldn't be editable by the client after creation
        allow update, delete: if false;
      }
    }

    // ✅ Products collection (admin-managed)
    match /products/{productId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // ✅ Role assignments collection (pre-assigned roles by email)
    match /roleAssignments/{email} {
      // Only admins can create/read/delete role assignments
      allow create, read, delete: if isAdmin() && isEmailVerified();
      allow update: if false; // Role assignments are immutable, delete and recreate to change
    }

    // ✅ Tickets collection (support inquiries)
    match /tickets/{ticketId} {
      // Only verified users can create tickets (guests cannot)
      allow create: if isSignedIn() && isEmailVerified()
        && request.resource.data.keys().hasOnly([
          'userId',
          'userEmail',
          'userName',
          'message',
          'status',
          'createdAt',
          'updatedAt',
          'viewedByAdmin',
          'timeline'
        ])
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.userEmail == request.auth.token.email
        && request.resource.data.status == 'open'
        && request.resource.data.message is string
        && request.resource.data.message.size() > 0
        && request.resource.data.viewedByAdmin == false;

      // Users can read their own tickets (must be verified)
      allow get, list: if isSignedIn() && isEmailVerified()
        && resource.data.userId == request.auth.uid;

      // Admins can read all tickets
      allow get, list: if isAdmin() && isEmailVerified();

      // Only admins can update tickets (to change status, mark as viewed, etc.)
      // Timeline is optional and can be added/updated
      function validTicketUpdate() {
        return request.resource.data.userId == resource.data.userId
          && request.resource.data.userEmail == resource.data.userEmail
          && request.resource.data.userName == resource.data.userName
          && request.resource.data.message == resource.data.message
          && request.resource.data.createdAt == resource.data.createdAt
          && request.resource.data.status is string;
      }
      allow update: if isAdmin() && isEmailVerified() && validTicketUpdate();

      // No one can delete tickets (for record keeping)
      allow delete: if false;
    }

    // Everything else locked down
    match /{document=**} {
      allow read, write: if false;
    }
  }
}